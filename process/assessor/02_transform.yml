- type: sql
  statements:
    - drop view if exists assessor.parcels_mapbox
    - create view assessor.parcels_mapbox as (
      select st_transform(shape, 4326) as wkb_geometry, parcelno from assessor.parcels_050318
      );
    - drop view if exists assessor.parcel_points
    - create view assessor.parcel_points as 
        (select 
          sh.objectid as objectid,
          sh.parcelno as parcelnum,
          left(sh.parcelno, 2) as ward,
          pm.propstreetcombined as address,
          cd.districts as council_district,
          pm.propzip as zip_code,
          pm.ownername1 as owner1,
          pm.ownername2 as owner2,
          pm.tax_send_to_name as taxpayer,
          pm.ownerstreetaddr as owner_street,
          pm.ownercity as owner_city,
          pm.ownerstate as owner_state,
          pm.ownerzip as owner_zip,
          pm.ownercountry as owner_country,
          pa.propclass as property_class,
          pa.exemptcode as taxable_status,
          pa."squareFootage" as sqft,
          pa."land_netAcres" as acreage,
          pa.land_front_0 as frontage,
          pa.land_depth_0 as depth,
          pa."MayPRE" as homestead_pre,
          nez."NEZ_PARCEL" as nez,
          greatest(pm.resb_yearbuilt, pm.cib_yearbuilt) as year_built,
          greatest(pm.resb_floorarea, pm.cib_floorarea) as floor_area,
          greatest(pm.resb_numresb, pm.cib_numcib) as num_buildings,
          pm.resb_style as building_style,
          pm."lastSalePrice" as last_sale_price,
          replace(pm."lastSaleDate"::varchar, ' ', 'T') as last_sale_date,
          pm."lastTermsOfSale" as last_terms_of_sale,
          pa.mborsev as sev,
          pa.ass as taxable_value,
          pm.landvalue as land_value,
          pm.bldgimprval as improved_value,
          pm."landMap" as landmap,
          pm.relatedpnum as related_parcel,
          pm.zoning as zoning,
          st_y(st_centroid(st_transform(sh.shape, 4326))) as latitude,
          st_x(st_centroid(st_transform(sh.shape, 4326))) as longitude,
          concat('location(', st_y(st_centroid(st_transform(sh.shape, 4326))), ',', st_x(st_centroid(st_transform(sh.shape, 4326))), ')') as location,
          lg.legal as legaldesc
        from assessor.parcels_050318 sh 
          left outer join assessor.parcels pa on sh.parcelno = pa.pnum
          left outer join assessor.parcelmaster pm on sh.parcelno = pm.pnum
          left outer join assessor.nezlist nez on sh.parcelno = nez."LAND_PARCEL"
          left outer join assessor.legals lg on sh.parcelno = lg.pnum
          left outer join base.council_districts cd on st_contains(cd.wkb_geometry, st_centroid(sh.shape))
          );
    - drop view if exists assessor.parcel_map
    - create view assessor.parcel_map as 
        (select 
          sh.objectid as objectid,
          sh.parcelno as parcelnum,
          left(sh.parcelno, 2) as ward,
          pm.propstreetcombined as address,
          cd.districts as council_district,
          pm.propzip as zip_code,
          pm.ownername1 as owner1,
          pm.ownername2 as owner2,
          pm.tax_send_to_name as taxpayer,
          pm.ownerstreetaddr as owner_street,
          pm.ownercity as owner_city,
          pm.ownerstate as owner_state,
          pm.ownerzip as owner_zip,
          pm.ownercountry as owner_country,
          pa.propclass as property_class,
          pa.exemptcode as taxable_status,
          pa."squareFootage" as sqft,
          pa."land_netAcres" as acreage,
          pa.land_front_0 as frontage,
          pa.land_depth_0 as depth,
          pa."MayPRE" as homestead_pre,
          nez."NEZ_PARCEL" as nez,
          greatest(pm.resb_yearbuilt, pm.cib_yearbuilt) as year_built,
          greatest(pm.resb_floorarea, pm.cib_floorarea) as floor_area,
          greatest(pm.resb_numresb, pm.cib_numcib) as num_buildings,
          pm.resb_style as building_style,
          pm."lastSalePrice" as last_sale_price,
          replace(pm."lastSaleDate"::varchar, ' ', 'T') as last_sale_date,
          pm."lastTermsOfSale" as last_terms_of_sale,
          pa.mborsev as sev,
          pa.ass as taxable_value,
          pm.landvalue as land_value,
          pm.bldgimprval as improved_value,
          pm."landMap" as landmap,
          pm.relatedpnum as related_parcel,
          pm.zoning as zoning,
          st_transform(sh.shape, 4326) as geom,
          lg.legal as legaldesc
        from assessor.parcels_050318 sh 
          left outer join assessor.parcels pa on sh.parcelno = pa.pnum
          left outer join assessor.parcelmaster pm on sh.parcelno = pm.pnum
          left outer join assessor.nezlist nez on sh.parcelno = nez."LAND_PARCEL"
          left outer join assessor.legals lg on sh.parcelno = lg.pnum
          left outer join base.council_districts cd on st_contains(cd.wkb_geometry, st_centroid(sh.shape))
          );
    # - drop view if exists assessor.parcels_accela;
    # - >- 
    #   create view assessor.parcels_accela as (
    #   select
    #     s.objectid,
    #     d.ward,-- WARD
    #     s.parcelno as parcelnumber, -- PARCELNUMBER
    #     d.district,   -- DISTRICT
    #     d.ecf,    -- ECF
    #     d.propaddr as propaddress,    -- PROPADDRESS
    #     d.propno::integer as "number",    -- NUMBER
    #     d.propdir as dir,   -- DIR
    #     d.propstr as street, -- STREET
    #     a.propzip as zipcode,   -- ZIPCODE
    #     a.ownername1 as taxpayername1,    -- TAXPAYERNAME1
    #     a.ownername2 as taxpayername2,   -- TAXPAYERNAME2
    #     a.ownerstreetaddr as taxpayeraddress,   -- TAYPAYERADDRESS
    #     a.ownercity as taxpayercity ,  -- CITY
    #     a.ownerstate as taxpayerstate,   -- STATE
    #     a.ownerzip as taxpayerzip,    -- ZIPCODE
    #     d."propclass" as "class",  -- CLASS
    #     d.prevpclass as previous,   -- PREVIOUS
    #     'Active' as status,   -- STATUS
    #     d.taxstatus as taxablestatus,    -- TAXABLESTATUS
    #     d.totalsqft::integer as sqft,    -- SQ. Ft.
    #     d.totalacreage as acreage,    -- ACREAGE
    #     d.frontage::integer as frontage,   -- FRONTAGE
    #     d."depth"::integer as "depth",  -- DEPTH
    #     d.usecode as usecode,    -- USECODE
    #     d.pre::integer as homestead,    -- HOMESTEADE
    #     d.nez,   -- NEZ
    #     a."xStreetName_0" as xstreetname1,   -- XSTREETNAME1
    #     a."xStreetName_1" as xstreetname2,    -- XSTREETNAME2
    #     a.relatedpnum as relatedparcel,    -- RELATEDPARCEL
    #     a.cib_floorarea as cifloorarea,    -- CIFLOORAREA
    #     a.cib_numcib as cibuildingno,    -- CIBUILDINGNO
    #     a.cib_occ as cioccupancy,    -- CIOCCUPANCY
    #     a.cib_yearbuilt as ciyearbuilt,  -- CIYEARBUILT
    #     a.resb_floorarea as resfloorarea,   -- RESFLOORAREA
    #     a.resb_numresb as resbuildingno,   -- RESBUILDINGNO
    #     a.resb_occ as resoccupancty,   -- RESOCCUPANCY
    #     a.resb_style as resbuildingstyle,   -- RESBUILDINGSTYLE
    #     a.resb_yearbuilt as resyearbuilt,   -- RESYEARBUILT
    #     a.vacant,    -- VACANT
    #     a."lastSalePrice" as lastsaleamount,   -- LASTSALEAMOUNT
    #     a."lastSaleDate" as lastsaledate,   -- LASTSALEDATE
    #     d.av::integer as assessedvalue,   -- ASSESSEDVALUE
    #     d.prevav::integer as prevassessvalue,    -- PREVASSESSVALUE
    #     d.sev::integer,   -- SEV
    #     d.prevav::integer as prevsev,    -- PREVSEV
    #     d.tv::integer as taxablevalue,   -- TAXABLEVALUE
    #     d.prevtv::integer as prevtaxablevalue,    -- PREVTAXABLEVALUE
    #     d.landvalue::integer as landvalue,    -- LANDVALUE
    #     d.landmap,   -- LANDMAP
    #     d.aka as akaaddress,   -- AKAADDRESS
    #     d.subdivision,    -- SUBDIVISION
    #     a.lot as lotnumber,   -- LOTNUMBER
    #     d.legaldesc as legaldescription,    -- LEGALDESCRIPTION
    #     d.rp,  -- RP
    #     s.shape as geom
    #   from assessor.parcels_050318 s
    #     inner join assessor.parcelmaster a
    #     on a.pnum = s.parcelno
    #     inner join assessor.parcel_data_18c d
    #     on d.parcelno = s.parcelno
    #    )
    - drop view if exists assessor.sales_history_socrata cascade
    - create view assessor.sales_history_socrata as (
        select
         id,
         addresscombined as address,
         pnum as parcel_no,
         replace(saledate::text, ' ', 'T') as sale_date,
         saleprice as sale_price,
         terms,
         instr as instrument,
         grantor,
         grantee,
         concat(
           'location(',
           st_y(st_centroid(st_transform(pa.shape, 4326))),
           ',',
           st_x(st_centroid(st_transform(pa.shape, 4326))),
           ')') as location,
         salenum as sale_number
         from assessor.sales sa
         inner join assessor.parcels_050318 pa on sa.pnum = pa.parcelno);
  