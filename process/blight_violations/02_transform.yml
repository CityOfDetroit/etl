- type: sql
  statements:
    # create a master table
    - drop table if exists dah.bvn cascade
    - create table dah.bvn (
        ticket_id,
        ticket_number,
        agency_name,
        inspector_name,
        violator_name,
        violation_street_number,
        violation_street_name,
        violation_zip_code,
        violator_id,
        mailing_address_str_number,
        mailing_address_str_name,
        city,
        state,
        zip_code,
        non_us_str_code,
        country,
        violation_date,
        ticket_issued_time,
        hearing_date,
        hearing_time,
        violation_code,
        violation_description,
        disposition,
        fine_amount,
        admin_fee,
        state_fee,
        late_fee,
        discount_amount,
        clean_up_cost,
        judgment_amount,
        payment_amount,
        balance_due,
        payment_date,
        payment_status,
        collection_status,
        violation_address,
        parcelno,
        latitude,
        longitude,
        location);
    # create indices on helper tables. speeds up ze joins
    - create index if not exists dah_bvn_zticket_idx on dah.bvn using btree(ticket_id);
    - create index if not exists dah_violator_info_idx on dah.violator_info using btree("ZTicketID");
    - create index if not exists dah_violator_address_idx on dah.violator_address using btree("ViolatorID");
    - create index if not exists dah_payment_id_idx on dah.payments using btree("ZticketID");
    # start joins
    - insert into dah.bvn (
        ticket_id,
        ticket_number,
        agency_name,
        inspector_name,
        violation_street_number,
        violation_street_name,
        violation_zip_code,
        violator_id,
        violation_date,
        ticket_issued_time,
        hearing_date,
        hearing_time,
        violation_code,
        violation_description,
        fine_amount,
        late_fee,
        admin_fee,
        state_fee,
        discount_amount,
        clean_up_cost
      )
      select
        "ZTicketID",
        "TicketNumber",
        # agency name
        (select "AgencyName" from dah.agency ag where ag."AgencyID" = z."AgencyID"),
        # inspector_name
        (select concat_ws(' ', s."UserFirstName", s."UserLastName") from dah.security s where z."ZTicketUserID" = s."SecurityID"),
        # violation_street_number
        "ViolStreetNumber",
        # violation_street_name
        (select "StreetName" from dah.streets s where s."StreetID" = z."ViolStreetName"),
        # violation_zip_code
        "ViolZipCode",
        (select "FileID" from dah.violator_info vi where vi."ZTicketID" = z."ZTicketID" ),
        "IssueDate"::timestamp,
        "IssueTime",
        # court_date - account for rescheduling
        (CASE
          WHEN ("ZTicketID" in (select "ZTicketID" from dah.reschedule)) THEN (select "ReScheduleDate" from dah.reschedule r where z."ZTicketID" = r."ZTicketID" order by "ReScheduleDate" desc limit 1)
          ELSE "CourtDate"
        END),
        # court_time
        (CASE 
          WHEN "CourtTime" = 1.0 THEN '9:00 AM'
          WHEN "CourtTime" = 2.0 THEN '10:30 AM'
          WHEN "CourtTime" = 3.0 THEN '1:30 PM'
          WHEN "CourtTime" = 4.0 THEN '3:00 PM'
          WHEN "CourtTime" = 5.0 THEN '6:00 PM'
          ELSE null
        END),
        # violation_code
        (select "OrdLaw" from dah.ordinance od where z."ViolDescID" = od."OrdID"),
        # violation_description
        (select "OrdDescription" from dah.ordinance od where z."ViolDescID" = od."OrdID"),
        # fine_amount
        (select "OffFineAmt" from dah.cityfines cf where z."OrigFineAmt" = cf."OffFinID"),
        "LateFee",
        "AdminFee",
        "JSA",
        "DiscAmt",
        # remediation cost
        (select sum("ServiceCost") from dah.blight_ticket_svc_cost bts where z."ZTicketID" = bts."ZTicketID" and bts."ServiceType" = 6)
      from dah.ztickets z where z."VoidTicket" = 0;
    # new fine amount
    - update dah.bvn j set fine_amount = z."NewFineAmt" from dah.ztickets z 
        where j.ticket_id = z."ZTicketID" and z."NewFineAmt" > 0;
    # join violator info
    - update dah.bvn j set
        violator_name = 
          CASE
            WHEN i."BusinessName" is not null THEN i."BusinessName"
            ELSE concat_ws(' ', i."FirstName", i."LastName")
          END
      from dah.violator_info i where j.ticket_id = i."ZTicketID";
    # join voilator address
    - update dah.bvn j set
        mailing_address_str_number = a."StreetNumber",
        mailing_address_str_name = a."StreetName",
        city = a."City",
        state = (select "StateAbrev" from dah.state s where s."StateID" = a."StateID"),
        zip_code = a."ZipCode",
        non_us_str_code = a."NonUsCity",
        country = (select "CountryDesc" from dah.country c where c."CountryID"::text = a."CountryID"::text)
      from dah.violator_address a where a."ViolatorID" = j.violator_id;
    # join dah payments
    - update dah.bvn j set
	      admin_fee = p."AdminFee",
	      state_fee = p."StateFee"
      from dah.payments p where j.ticket_id = p."ZticketID";
    # compute judgment amount: sum OrigFineAmt, AdminFee, StateFee, LateFee, RemediationCost, minus DiscAmt
    - update dah.bvn j
	      set judgment_amount = (
		      COALESCE(fine_amount, 0) + 
		      COALESCE(admin_fee, 0) + 
          COALESCE(state_fee, 0) + 
          COALESCE(late_fee, 0) + 
          COALESCE(clean_up_cost, 0) -
          COALESCE(discount_amount, 0));
    # compute payment amount: sum all rows with PaymentAmt for a unique ZTicketID
    - update dah.bvn j set
	      payment_amount = (select sum("PaymentAmt") from dah.payments where "ZticketID" = j.ticket_id);
    - update dah.bvn j set
        payment_amount = judgment_amount
            where j.ticket_id in (select "ZticketID" from dah.payments where "PymtKnd" = 2);
    # compute balance due
    - update dah.bvn j
        set balance_due = (judgment_amount - COALESCE(payment_amount, 0));
    # compute payment date
    - update dah.bvn j set
	      payment_date = (select max("PaymentDt") from dah.payments where "ZticketID" = j.ticket_id and dah.payments."PymtKnd" != 5);
    # create disposition string
    - update dah.bvn j 
        set disposition =
          case 
            when da."SetAside" != 'NaN' THEN 'PENDING'
            else
              (select concat_ws(' ',
                (select dt."Distype" from dah.disp_type dt where da."RespType" = dt."DispositionID"), 
                'by',
                (select dt."Distype" from dah.disp_type dt where da."DispositionID" = dt."DispositionID")
                )
              )
            end 
        from (select * from dah.dispadjourn da order by "EntryDt" desc) da where da."ZTicketID" = j.ticket_id;
    # if disposition is "not responsible", set payment and judgment to $0 (bc might be refunded)
    - update dah.bvn j set 
        payment_amount = 0, 
        judgment_amount = 0, 
        admin_fee = 0, 
        state_fee = 0,
        balance_due = 0
      where disposition like 'Not resp%';
    # create payment status
    - update dah.bvn j
        set payment_status = (
          CASE 
            WHEN 
            (j.disposition LIKE 'Not responsible%' OR
              j.disposition LIKE 'Responsible (Fine Waived)%') THEN 'NO PAYMENT DUE'
            WHEN j.payment_amount = 0 THEN 'NO PAYMENT APPLIED'
            WHEN j.payment_amount > 0 and j.balance_due > 0 THEN 'PARTIAL PAYMENT APPLIED'
            WHEN j.ticket_id in (select "ZticketID" from dah.payments where "PymtKnd" = 2) THEN 'PAID IN FULL'
            ELSE null
          END);
    # zero out balance due where no payment due
    - update dah.bvn j set
        balance_due = 0 where j.payment_status = 'NO PAYMENT DUE';
    # create collection status
    - update dah.bvn j
        set collection_status = 'In collections' where j.ticket_id in (select "ZTicketID" from dah.dispadjourn where "CollectionFlag" != 'NaN');
    # create violation address
    - update dah.bvn j
        set violation_address = concat_ws(' ', violation_street_number, violation_street_name);
    # join on parcel address (geocode in future bc dah addresses often lack direction, therefore don't match)
    - update dah.bvn j set 
        parcelno = a.parcelno,
        latitude = ST_Y(ST_Transform(ST_Centroid(wkb_geometry), 4326)),
        longitude = ST_X(ST_Transform(ST_Centroid(wkb_geometry), 4326))
      from base.joined a where trim(lower(j.violation_address)) = trim(lower(a.propaddr));
- type: sql
  statements:
    # create view for open data
    - drop view if exists dah.bvn_socrata
    - create view dah.bvn_socrata as 
      (select
        ticket_id,
        ticket_number,
        agency_name,
        inspector_name,
        violator_name,
        violation_street_number,
        violation_street_name,
        violation_zip_code,
        violator_id,
        mailing_address_str_number,
        mailing_address_str_name,
        city,
        state,
        zip_code,
        non_us_str_code,
        country,
        violation_date,
        ticket_issued_time,
        hearing_date,
        hearing_time,
        violation_code,
        violation_description,
        disposition,
        fine_amount,
        admin_fee,
        state_fee,
        late_fee,
        discount_amount,
        clean_up_cost,
        judgment_amount,
        payment_amount,
        balance_due,
        payment_date,
        payment_status,
        collection_status,
        violation_address,
        parcelno,
        latitude,
        longitude,
        concat(
          'location(', 
          latitude, 
          ',', 
          longitude, 
          ')'
        ) as location
      from dah.bvn)
